{
  "name": "Nativefier",
  "version": "0.1.0",
  "summary": "Cache library for iOS",
  "description": "Features\n  \n  - Builder pattern\n  - Default Cache for Image and any HandyJSON object <https://github.com/alibaba/HandyJSON>\n  - Support synchronous or asynchronous operation\n  - Delegate when object is about to removed from cache\n  - Custom fetcher closure to get object if object is not present in the cache\n  - Dual cache on Disk and Memory\n\nRequirements\n  \n  - Swift 3.2 or higher\n  \nAbout Nativefier\n\n  The basic algorithm of nativefier is very simple\n  \n  Stored object\n  1. Object will be stored on memory and then disk asynchronously\n  2. If memory is already full, the least and oldest accessed object will be removed to give room for the new object\n  3. If Disk is already full, the least and oldest accessed object will be removed to give room for the new object\n  \n  Getting the object\n  1. It will be return the stored object if the object is already in memory\n  2. If the object is not present in the memory, it will be search in the disk and will stored the object found in the memory as new object\n  3. If the object is not found, it will return nil\n  4. If you're using the getOrFetch method, then it will fetch the object using your custom fetcher if the object is not found anywhere and stored the object from fetcher as new object to memory and disk\n  \nUsage Example\n  HandyJSON and Image\n  Build the object using HttpRequestBuilder and then execute\n  \n  - containerName is name of cache folder in disk\n  - maxRamCount is max number of object can stored in memory\n  - maxDiskCount is max number of object can stored in disk\n  \n  code :\n  //HandyJSON object cache\n  let handyJSONCache = NativefierBuilder.getForHandyJSON<MyObject>().set(containerName: \"myobject\").set(maxRamCount: 100).set(maxDiskCount: 200).build()\n  \n  //Image cache\n  let imageCache = NativefierBuilder.getForImage().set(maxRamCount: 100).set(maxDiskCount: 200).build()\n  \n  \n  Any Object\n  If you prefer custom object you can create your own serializer for your cache\n  \n  code:\n  class MyOwnSerializer : NativefierSerializerProtocol{\n      \n      func serialize(obj : AnyObject) -> Data? {\n          guard let myObject : MyObject = obj as? MyObject else {\n              return nil\n          }\n          //ANY CODE TO CONVERT YOUR OBJECT TO DATA\n          return serializedData\n      }\n      \n      func deserialize(data : Data) -> AnyObject? {\n          //ANY CODE TO CONVERT DATA TO YOUR OBJECT\n          return deserializedObject\n      }\n      \n  }\n  \n  And then create your cache\n  \n  code:\n  let handyJSONCache = NativefierBuilder.getForAnyObject<MyObject>().set(containerName: \"myobject\").set(maxRamCount: 100).set(maxDiskCount: 200).set(serializer: MyOwnSerializer()).build()\n  \n  \n  Create Fetcher\n  Fetcher is closure that will be executed if the object you want to get is not present in memory or disk. The object returned from the fetcher will be stored in cache\n  \n  code:\n  let handyJSONCache = NativefierBuilder.getForAnyObject<MyObject>().set(containerName: \"myobject\").set(maxRamCount: 100).set(maxDiskCount: 200).set(serializer: MyOwnSerializer())\n  .set(fetcher: { key in\n       //ANY CODE TO FETCH THE OBJECT USING THE GIVEN KEY\n       return fetchedObject\n       }).build()\n       \n       \n  Using The Nativefier\n  Using the nativefier is very easy. just use it like you use Dictionary object.\n  But remember, if you want to using fetcher, its better to do it asynchronously so it wouldn't block your execution if fetch take to long\n           \n  code:\n  let object = myCache[\"myKey\"]\n  myCache[\"newKey\"] = myNewObject\n           \n  //Using fetcher if its not found anywhere\n  let fetchedObject = myCache.getOrFetch(forKey : \"myKey\")\n           \n  //Using async, it will automatically using fetcher if the object is not found anywhere and you have fetcher.\n  myCache.asyncGet(forKey: \"myKey\", onComplete: { object in\n        guad let object : MyObject = object as? MyObject else {\n            return\n        }\n        //DO SOMETHING WITH YOUR OBJECT\n  })\n  \n                            \n  Using Delegate\n  If you need to use delegate, you need to implement the delegate and then put it in your cache is it will executed by the cache.\n  The delegate method you can use is :\n  - nativefier(_ nativefier : Any , onFailedFecthFor key: String) -> Any?\n    will be executed if fetcher failed to get the object, you can return any default object and it will not stored in the cache\n  - nativefier(_ nativefier : Any, memoryWillRemove singleObject: Any, for key: String)\n    will be executed if nativefier is about to remove some object from memory\n  - nativefierWillClearMemory(_ nativefier : Any)\n    will be executed if nativefier will clear the memory\n  - nativefier(_ nativefier : Any, diskWillRemove singleObject: Any, for key: String)\n    will be executed if nativefier is about to remove some object from disk\n  - nativefierWillClearDisk(_ nativefier : Any)\n    will be executed if nativefier will clear the disk\n    \n  All method are optional, use the one you need\n                            \n  code:\n  // on build\n  let imageCache = NativefierBuilder.getForImage().set(maxRamCount: 100).set(maxDiskCount: 200).set(delegate : self).build()\n                            \n  // or directly to the Nativefier Object\n  imageCache.delegate = self",
  "homepage": "https://github.com/nayanda1/iOSNativefier",
  "license": {
    "type": "MIT",
    "file": "LICENSE"
  },
  "authors": {
    "nayanda1": "nayanda1@outlook.com"
  },
  "source": {
    "git": "https://github.com/nayanda1/iOSNativefier.git",
    "tag": "0.1.0"
  },
  "platforms": {
    "ios": "8.0"
  },
  "source_files": "Nativefier/Classes/**/*",
  "swift_version": "3.2",
  "dependencies": {
    "HandyJSON": [
      "~> 4.1.1"
    ]
  }
}
