{
  "name": "SpaceFactoryNetworking",
  "version": "0.0.1",
  "summary": "A networking library on top of NSURLSession",
  "homepage": "https://github.com/daltonclaybrook/SpaceFactoryNetworking",
  "license": {
    "type": "MIT",
    "file": "LICENSE"
  },
  "authors": {
    "Dalton Claybrook": "daltonclaybrook@gmail.com"
  },
  "social_media_url": "http://twitter.com/daltonclaybrook",
  "platforms": {
    "ios": "7.0"
  },
  "source": {
    "git": "https://github.com/daltonclaybrook/SpaceFactoryNetworking.git",
    "tag": "0.0.1"
  },
  "source_files": "SpaceFactoryNetworking/Core/**/*.{h,m}",
  "public_header_files": "SpaceFactoryNetworking/Core/Public Headers/**/*.h",
  "requires_arc": true,
  "description": "                   # SpaceFactoryNetworking\n\n***\n\nA collection of classes useful for fetching and persisting file data. Built on top of **NSURLSession**.\n\n## Features\n\n***\n\n- Download data directly to disk from an **NSURL** or **NSURLRequest**.\n- Files continue to download when the app is suspended.\n- Data is automatically moved to persistent storage on disk.\n- Data can be encrypted using standard iOS disk encryption.\n- If protected file access is unavailable, data is queued for encryption at a later date.\n- Specify a disk size limit in bytes. If data on disk exceeds this limit, specific files are chosen and evicted using a combination of the file's **last access date** and **file size**.\n- Specify an **identifier** when fetching a file. This identifier can be used to check for the existence of a file on disk, or to evict a file.\n- Specify an optional **file group** for each file to associate it with other files.\n- Initiate a manual eviction of a file with an **identifier** and **file group**, evict all files in a **file group**, or evict the entire disk cache.\n- Ignore the results of a currently running fetch operation. This uninstalls the completion handler, but continues downloading the file.\n- If a fetch is in progress, and another fetch is initiated for the same resource, the second completion handler is installed on the currently running fetch, preventing duplicate data.\n- Inject existing data to be persisted by the file manager.\n- **Image Manager** uses a **file manager** to fetch / persist image data specifically.\n\n## Usage\n\n***\n\nInitialization & Configuration:\n\n    self.fileManager = [[SFSFileManager alloc] init];\n    self.fileManager.usesEncryptionByDefault = YES;\n    self.fileManager.diskSizeLimit = 512 * 1024 * 1024; // 512 MB\n    \nSimplest Fetch:\n\n    NSURL *url = [NSURL URLWithString:@\"http://placekitten/600/500\"];\n    [self.fileManager fetchFileDataAtURL:url withCompletion:^(NSURL *fileURL, NSError *error) {\n    \n        // data fetched using '[url absoluteString]' as the identifier \n        // and 'SFSFileManagerDefaultFileGroup' as the file group\n        //\n        // \n    }];\n    \nComplex Fetch:\n\n    NSURL *url = [NSURL URLWithString:@\"http://myapi.com/users\"];\n    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];\n    [request setValue:<#auth string#> forHTTPHeaderField:@\"Authorization\"];\n    \n    NSString *myIdentifier = @\"12345\";\n    NSString *myGroup = @\"userDataGroup\";\n    \n    __typeof__(self) __weak weakSelf = self;\n    id<SFSTask> task = [self.fileManager fetchFileDataForRequest:request usingIdentifier:myIdentifier fileGroup:myGroup usingDiskEncryption:YES withCompletion:^(NSURL *fileURL, NSError *error) {\n        \n        [weakSelf useFileAtURL:fileURL error:error];\n    }];\n    \n    // Some time later...\n    \n    if ([task isRunning])\n    {\n        [task ignoreResults]; //will cause the above completion block to not be called, but will not cancel the request.\n        // or\n        [task cancelRequest];\n    }\n    \nImage Manager:\n\n    self.imageManager = [[SFSImageManager alloc] initWithFileManager:nil]; \n    // causes a file manager to be created for you.\n    \n    NSURL *url = [NSURL URLWithString:@\"http://placekitten/600/500\"];\n    \n    __typeof__(self) __weak weakSelf = self;\n    [self.imageManager fetchImageAtURL:url withCompletion:^(UIImage *image, NSError *error) {\n        \n        // completion is executed on the main thread.\n        weakSelf.imageView.image = image;\n    }];\n    \n## Integration\n\n*** \n\nBy far, the easiest way to integrate **SpaceFactoryNetworking** is using [CocoaPods](http://cocoapods.org):\n\n    # Example Podfile\n    pod 'SpaceFactoryNetworking'\n    \nOtherwise, you can clone this repo, and import files from the **'SpaceFactoryNetworking/Core'** folder.\n\n## Collaborate\n\n***\n\nYou are welcome to submit pull requests to this project. If you are considering doing so, please reach out to me at [daltonclaybrook@gmail.com](mailto:daltonclaybrook@gmail.com). I'd like to touch base.\n\n##### Potential additions:\n\n- Unit Tests (much needed)\n- More screens in the **Example app** to demonstrate functionality\n- Callbacks to report progress on a download\n\n##### Known Issues:\n\n- File access may not fail gracefully if the protected file is accessed while the app is in the background and the device is locked.\n\n"
}
