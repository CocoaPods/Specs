{
  "name": "MatrixFlow",
  "version": "0.0.3",
  "summary": "# MatrixFlow\nA CocoaPods library for swift-driven matrix and image operations, offering seamless integration of CoreML and Accelerate frameworks for optimized machine learning and mathematical computations.\n\n<img src=\"https://developer.apple.com/assets/elements/icons/create-ml-framework/create-ml-framework-96x96_2x.png\"  width=\"10%\" height=\"10%\">\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/9/9d/Swift_logo.svg/1024px-Swift_logo.svg.png\"  width=\"20%\" height=\"20%\">\n\nMatrixFlow is a sophisticated Swift library that harnesses the power of CoreML and the Accelerate framework. Its primary purpose is to offer user-friendly solutions for intricate challenges in matrix manipulation, image processing, machine learning processing, and beyond. \n\nThe Accelerate framework offers exposure to SIMD instructions inherent in contemporary CPUs, which in turn, markedly enhances the performance of certain computational tasks. Regrettably, due to its somewhat arcane nature and less-than-intuitive APIs, many developers bypass the Accelerate framework. This oversight is unfortunate, considering the potential performance enhancements that many applications stand to gain from its integration. \n\nMatrixFlow is strategically positioned to bridge this disconnect. It simplifies the complexities tied to matrix manipulations with mlmultiarray, providing developers an intuitive interface to execute Python-esque functions such as: \n\nComparison table between the functions inside MatrixFlow and their similar Python functions, particularly with the `numpy` library, which is commonly used for matrix operations in Python.\n\n| **Swift Function**       | **Python (numpy) Equivalent** | **Math Representation** |\n|--------------------------|-------------------------------|-------------------------|\n| ConvertMultiArrayToArray4d | `numpy.asarray()` (with shape adjustment) | <img src=\"https://latex.codecogs.com/gif.latex?A%20\\in%20\\mathbb{R}^{w%20\\times%20x%20\\times%20y%20\\times%20z}%20\\\" />  |\n| MultiplyMatrices        | `numpy.dot()` | <img src=\"https://latex.codecogs.com/gif.latex?C%20=%20A%20\\times%20B%20\\text{%20where%20}%20A%20\\in%20\\mathbb{R}^{m%20\\times%20n}%20\\text{%20and%20}%20B%20\\in%20\\mathbb{R}^{n%20\\times%20p}\" />  |\n| ReshapeToMatrix         | `numpy.reshape()` | <img src=\"https://latex.codecogs.com/gif.latex?C%20=%20B%20=%20\\text{reshape}(A,%20(m,%20n%20\\times%20o))%20\\text{%20where%20}%20A%20\\in%20\\mathbb{R}^{m%20\\times%20n%20\\times%20o}\" />  |\n| SigmoidMatrix           | `def sigmoid(x):return 1 / (1 + np.exp(-x))` | <img src=\"https://latex.codecogs.com/gif.latex?S(x)%20=%20\\frac{1}{1%20+%20e^{-x}}\" /> |\n| ConvertMultiArrayToArray | `numpy.asarray()` (with shape adjustment) | <img src=\"https://latex.codecogs.com/gif.latex?\\(%20B%20=%20\\text{reshape}(A,%20(m,%20n%20\\times%20o))%20\\)%20where%20\\(%20A%20\\in%20\\mathbb{R}^{m%20\\times%20n%20\\times%20o}%20\\\" /> |\n| Transpose               | `numpy.transpose()` | <img src=\"https://latex.codecogs.com/gif.latex?\\(%20B%20=%20A^T%20\\)%20where%20\\(%20A%20\\in%20\\mathbb{R}^{m%20\\times%20n}%20\\)\"/> |\n| ReshapeArray            | `numpy.reshape()` | <img src=\"https://latex.codecogs.com/gif.latex?\\(%20B%20=%20\\text{reshape}(A,%20(m,%20n%20\\times%20o))%20\\)%20where%20\\(%20A%20\\in%20\\mathbb{R}^{m%20\\times%20n%20\\times%20o}%20\\)\"/> |\n| Slice                   | `matrix[:5]` | <img src=\"https://latex.codecogs.com/gif.latex?B%20=%20A_{[:k]}%20\\text{%20where%20}%20k%20\\text{%20is%20the%20number%20of%20rows/columns%20to%20slice}\"/> |\n| CombineMatrix           | `numpy.hstack()` | <img src=\"https://latex.codecogs.com/gif.latex?C%20=%20\\text{hstack}(A,%20B)%20\\text{%20for%20horizontally%20stacking%20matrices%20}%20A%20\\text{%20and%20}%20B\"/> |\n\n\nIts vast potential makes it a valuable asset for diverse applications, from gaming to machine learning development, all within the Swift ecosystem. \n\n**Target Audience**: Individuals seeking streamlined solutions to manipulate multiarray matrices and process CoreML outputs.\n\nAdditionally, here's a brief guide on how to install the `MatrixFlow` library using different package managers:\n\n---\n\n### Installation Guide for MatrixFlow\n\n**1. Swift Package Manager:**\n   \nTo integrate `MatrixFlow` into your Xcode project using Swift Package Manager, add the following as a dependency to your `Package.swift`:\n\n```swift\ndependencies: [\n    .package(url: \"https://github.com/jadechoghari/MatrixFlow.git\", .upToNextMajor(from: \"1.0.0\"))\n]\n```\n\nThen, simply import `MatrixFlow` wherever you need it.\n\n**2. CocoaPods:**\n\nFirstly, ensure you have CocoaPods installed. If not, install it using:\n\n```\n$ gem install cocoapods\n```\n\nNext, create a `Podfile` in your project directory (if you haven't) and add:\n\n```\npod 'MatrixFlow'\n```\n\nNow, run the following command:\n\n```\n$ pod install\n```\n\nPost installation, ensure to open your project's `.xcworkspace`.\n\n**3. Carthage:**\n\nEnsure you have Carthage installed. If not, you can get it via Homebrew:\n\n```\n$ brew install carthage\n```\n\nThen, create a `Cartfile` in your project directory (if you haven't) and add:\n\n```\ngithub \"jadechoghari/MatrixFlow\"\n```\n\nNow, execute:\n\n```\n$ carthage update\n```\n\nAfter it's done, add the built `.framework` binaries to your target's \"Linked Frameworks and Libraries\" section in Xcode.\n\n---\n\n### MatrixFlow Usage Guide\n\n---\n\n**1. ConvertMultiArrayToArray4d:** \n\nThis function seamlessly transforms a 4D `MLMultiArray` into a structured 4D matrix tailored for immediate application. The resulting matrix is of type `[[[[Decimal]]]]`, leveraging the Decimal type to ensure precision in the data representation.\n\n**Usage:** \n\n```swift\nimport MatrixFlow\n// Generating a 4D MLMultiArray\nguard let multiArray = try? MLMultiArray(shape: shape, dataType: .float32) else { \n    fatalError(\"Failed to create MLMultiArray\") \n}\n\n// Populate the MLMultiArray with some values\nfor i in 0..<shape[0].intValue {\n    for j in 0..<shape[1].intValue {\n        for k in 0..<shape[2].intValue {\n            for l in 0..<shape[3].intValue {\n                let indices = [i, j, k, l] as [NSNumber]\n                multiArray[indices] = NSNumber(value: i + j + k + l)\n            }\n        }\n    }\n}\n\nlet fourArray = MatrixFlow.convertMultiArrayToArray4d(multiArray)\n```\n\n**Expected Result of type :** \n\n```swift\n[[[[0, 1], [1, 2], [2, 3], [3, 4]], [[1, 2], [2, 3], [3, 4], [4, 5]], [[2, 3], [3, 4], [4, 5], [5, 6]]]]\n//of type [[[[Decimal]]]]\n```\n\n---\n\n**2. MultiplyMatrices:** \n\nThe function accepts two 2D matrices and performs matrix multiplication. For instance, a (2, 4) matrix multiplied with a (4, 8) matrix.\n\n**Usage:**\n\n```swift\nimport MatrixFlow\nlet matrixA: [[Decimal]] = [[1, 2, 3], [4, 5, 6]]\nlet matrixB: [[Decimal]] = [[7, 8], [9, 10], [11, 12]]\n\n//Perform multiplication\nlet result = MatrixFlow.multiplyMatrices(matrixAA, matrixBB)\n\n//expected results of type [[Decimal]]: [[58, 64], [139, 154]]\n```\n\n---\n\n**3. ReshapeToMatrix:** \n\nThis function accepts a 2D matrix and reshapes it, effectively halving its dimensions. For example, it can transform a (3, 25600) matrix into a (3, 160, 160) structure.\n\n``` swift\nimport MatrixFlow\nlet flattenedArray: [Decimal] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]\nlet rows = 5\nlet columns = 5\n// specifiy the number of rows and columns you'll need accordingly\nlet result = MatrixFlow.reshapeToMatrix(array: flattenedArray, rows: rows, cols: columns)\n\n//expected result of type [[Decimal]]\n// [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]]\n\n```\n\n---\n\n**4. SigmoidMatrix:** \n\nImplements the sigmoid activation function to each cell of a matrix of type `[[Decimal]]`.\n\n**Usage:**\n\n```swift\nimport MatrixFlow\nlet matrix: [[Decimal]] = [\n    [1.8, 2.0, 3.0], \n    [4.9, 5.0, 6.0], \n    [7.0, 8.0, 9.0]\n]\n\nlet result: [[Decimal]] = MatrixFlow.sigmoidMatrix(matrix)\n//expected result: [[Decimal]] = [[0.8581489350995122176, 0.880797077977882624, 0.9525741268224335872], [0.9926084586557181952, 0.9933071490757152768, 0.9975273768433655808], [0.9990889488055998464, 0.9996646498695335936, 0.9998766054240137216]]\n```\n\n**5. ConvertMultiArrayToArray:**\n\nThis function is designed to convert an `MLMultiArray` with three dimensions into a 3D matrix ready for use.\n\n**Usage:**\n\n```swift\nimport MatrixFlow\nlet shape: [NSNumber] = [1, 3, 4]\n\nguard let multiArray = try? MLMultiArray(shape: shape, dataType: .float32) else {\n    fatalError(\"Failed to create MLMultiArray\")\n}\n\n// Populate the MLMultiArray\nfor i in 0..<shape[0].intValue {\n    for j in 0..<shape[1].intValue {\n        for k in 0..<shape[2].intValue {\n            let indices = [i, j, k] as [NSNumber]\n            multiArray[indices] = NSNumber(value: i + j + k)\n        }\n    }\n}\nlet result: [[[Decimal]]] = MatrixFlow.convertMultiArrayToArray(multiArray)\n\n// expected result: [[[Decimal]]] = [[[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5]]]\n```\n\n---\n\n**6. Transpose:**\n\n\nThis function transposes a 2D matrix, essentially swapping its rows with columns.\n\n**Usage:**\n``` swift\nimport MatrixFlow\nlet array: [[Decimal]] = [[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5]]\n\nlet result = MatrixFlow.transpose(array)\n\n//expected result: [[Decimal]] = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5]]\n```\n\n---\n\n**7. ReshapeArray:**\n\nThis function reshapes a 3D matrix by merging its last two dimensions.\n\n**Usage:**\n\n```swift\nimport MatrixFlow\nlet array: [[[Decimal]]] = [[[1.1, 1.2], [1.3, 1.4], [1.5, 1.6], [1.7, 1.8]], [[2.1, 2.2], [2.3, 2.4], [2.5, 2.6], [2.7, 2.8]], [[3.1, 3.2], [3.3, 3.4], [3.5, 3.6], [3.7, 3.8]]]\n\nlet result = MatrixFlow.reshapeArray(inputArray: array)\n\n//expected result: [[Decimal]] = [[1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8], [2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8], [3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8]]\n```\n\n---\n\n**8. Slice:**\n\nThis function performs matrix slicing. Given a matrix, it retrieves the first five rows.\n\n**Usage:**\n\n```swift\nimport MatrixFlow\nlet input: [[Decimal]] = [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 50], [11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 15], [21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 16]]\n\n//Specify the start and end index of the slicing\nlet start = 0\nlet end = 5\n\nlet result = MatrixFlow.slice(inputArray: input, start: 0, end: 5)\n\n//expected result: [[Decimal]] = [[1, 2, 3, 4, 5], [11, 12, 13, 14, 15], [21, 22, 23, 24, 25]]\n```\n\n---\n\n**9. CombineMatrix:**\n\nThis function is analogous to the numpy `hstack` operation. It horizontally stacks two matrices.\n\n**Usage:**\n\n```swift\nimport MatrixFlow\n// boxes and masks are named for illustration purposes\nlet arrayA: [[Decimal]] = [[1, 2, 3, 4, 5], [11, 12, 13, 14, 15], [21, 22, 23, 24, 25]]\nlet arrayB: [[Decimal]] = [[6, 7, 8, 9, 10, 50], [16, 17, 18, 19, 20, 15], [26, 27, 28, 29, 30, 16]]\n\nlet result = MatrixFlow.combineMatrix(boxes: arrayA, masks: arrayB)\n\n//expected results: [[Decimal]] = [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 50], [11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 15], [21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 16]]\n```",
  "swift_versions": "5.0",
  "description": "# MatrixFlow\nA CocoaPods library for swift-driven matrix and image operations, offering seamless integration of CoreML and Accelerate frameworks for optimized machine learning and mathematical computations.\n\n<img src=\"https://developer.apple.com/assets/elements/icons/create-ml-framework/create-ml-framework-96x96_2x.png\"  width=\"10%\" height=\"10%\">\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/9/9d/Swift_logo.svg/1024px-Swift_logo.svg.png\"  width=\"20%\" height=\"20%\">\n\nMatrixFlow is a sophisticated Swift library that harnesses the power of CoreML and the Accelerate framework. Its primary purpose is to offer user-friendly solutions for intricate challenges in matrix manipulation, image processing, machine learning processing, and beyond. \n\nThe Accelerate framework offers exposure to SIMD instructions inherent in contemporary CPUs, which in turn, markedly enhances the performance of certain computational tasks. Regrettably, due to its somewhat arcane nature and less-than-intuitive APIs, many developers bypass the Accelerate framework. This oversight is unfortunate, considering the potential performance enhancements that many applications stand to gain from its integration. \n\nMatrixFlow is strategically positioned to bridge this disconnect. It simplifies the complexities tied to matrix manipulations with mlmultiarray, providing developers an intuitive interface to execute Python-esque functions such as: \n\nComparison table between the functions inside MatrixFlow and their similar Python functions, particularly with the `numpy` library, which is commonly used for matrix operations in Python.\n\n| **Swift Function**       | **Python (numpy) Equivalent** | **Math Representation** |\n|--------------------------|-------------------------------|-------------------------|\n| ConvertMultiArrayToArray4d | `numpy.asarray()` (with shape adjustment) | <img src=\"https://latex.codecogs.com/gif.latex?A%20\\in%20\\mathbb{R}^{w%20\\times%20x%20\\times%20y%20\\times%20z}%20\\\" />  |\n| MultiplyMatrices        | `numpy.dot()` | <img src=\"https://latex.codecogs.com/gif.latex?C%20=%20A%20\\times%20B%20\\text{%20where%20}%20A%20\\in%20\\mathbb{R}^{m%20\\times%20n}%20\\text{%20and%20}%20B%20\\in%20\\mathbb{R}^{n%20\\times%20p}\" />  |\n| ReshapeToMatrix         | `numpy.reshape()` | <img src=\"https://latex.codecogs.com/gif.latex?C%20=%20B%20=%20\\text{reshape}(A,%20(m,%20n%20\\times%20o))%20\\text{%20where%20}%20A%20\\in%20\\mathbb{R}^{m%20\\times%20n%20\\times%20o}\" />  |\n| SigmoidMatrix           | `def sigmoid(x):return 1 / (1 + np.exp(-x))` | <img src=\"https://latex.codecogs.com/gif.latex?S(x)%20=%20\\frac{1}{1%20+%20e^{-x}}\" /> |\n| ConvertMultiArrayToArray | `numpy.asarray()` (with shape adjustment) | <img src=\"https://latex.codecogs.com/gif.latex?\\(%20B%20=%20\\text{reshape}(A,%20(m,%20n%20\\times%20o))%20\\)%20where%20\\(%20A%20\\in%20\\mathbb{R}^{m%20\\times%20n%20\\times%20o}%20\\\" /> |\n| Transpose               | `numpy.transpose()` | <img src=\"https://latex.codecogs.com/gif.latex?\\(%20B%20=%20A^T%20\\)%20where%20\\(%20A%20\\in%20\\mathbb{R}^{m%20\\times%20n}%20\\)\"/> |\n| ReshapeArray            | `numpy.reshape()` | <img src=\"https://latex.codecogs.com/gif.latex?\\(%20B%20=%20\\text{reshape}(A,%20(m,%20n%20\\times%20o))%20\\)%20where%20\\(%20A%20\\in%20\\mathbb{R}^{m%20\\times%20n%20\\times%20o}%20\\)\"/> |\n| Slice                   | `matrix[:5]` | <img src=\"https://latex.codecogs.com/gif.latex?B%20=%20A_{[:k]}%20\\text{%20where%20}%20k%20\\text{%20is%20the%20number%20of%20rows/columns%20to%20slice}\"/> |\n| CombineMatrix           | `numpy.hstack()` | <img src=\"https://latex.codecogs.com/gif.latex?C%20=%20\\text{hstack}(A,%20B)%20\\text{%20for%20horizontally%20stacking%20matrices%20}%20A%20\\text{%20and%20}%20B\"/> |\n\n\nIts vast potential makes it a valuable asset for diverse applications, from gaming to machine learning development, all within the Swift ecosystem. \n\n**Target Audience**: Individuals seeking streamlined solutions to manipulate multiarray matrices and process CoreML outputs.\n\nAdditionally, here's a brief guide on how to install the `MatrixFlow` library using different package managers:\n\n---\n\n### Installation Guide for MatrixFlow\n\n**1. Swift Package Manager:**\n   \nTo integrate `MatrixFlow` into your Xcode project using Swift Package Manager, add the following as a dependency to your `Package.swift`:\n\n```swift\ndependencies: [\n    .package(url: \"https://github.com/jadechoghari/MatrixFlow.git\", .upToNextMajor(from: \"1.0.0\"))\n]\n```\n\nThen, simply import `MatrixFlow` wherever you need it.\n\n**2. CocoaPods:**\n\nFirstly, ensure you have CocoaPods installed. If not, install it using:\n\n```\n$ gem install cocoapods\n```\n\nNext, create a `Podfile` in your project directory (if you haven't) and add:\n\n```\npod 'MatrixFlow'\n```\n\nNow, run the following command:\n\n```\n$ pod install\n```\n\nPost installation, ensure to open your project's `.xcworkspace`.\n\n**3. Carthage:**\n\nEnsure you have Carthage installed. If not, you can get it via Homebrew:\n\n```\n$ brew install carthage\n```\n\nThen, create a `Cartfile` in your project directory (if you haven't) and add:\n\n```\ngithub \"jadechoghari/MatrixFlow\"\n```\n\nNow, execute:\n\n```\n$ carthage update\n```\n\nAfter it's done, add the built `.framework` binaries to your target's \"Linked Frameworks and Libraries\" section in Xcode.\n\n---\n\n### MatrixFlow Usage Guide\n\n---\n\n**1. ConvertMultiArrayToArray4d:** \n\nThis function seamlessly transforms a 4D `MLMultiArray` into a structured 4D matrix tailored for immediate application. The resulting matrix is of type `[[[[Decimal]]]]`, leveraging the Decimal type to ensure precision in the data representation.\n\n**Usage:** \n\n```swift\nimport MatrixFlow\n// Generating a 4D MLMultiArray\nguard let multiArray = try? MLMultiArray(shape: shape, dataType: .float32) else { \n    fatalError(\"Failed to create MLMultiArray\") \n}\n\n// Populate the MLMultiArray with some values\nfor i in 0..<shape[0].intValue {\n    for j in 0..<shape[1].intValue {\n        for k in 0..<shape[2].intValue {\n            for l in 0..<shape[3].intValue {\n                let indices = [i, j, k, l] as [NSNumber]\n                multiArray[indices] = NSNumber(value: i + j + k + l)\n            }\n        }\n    }\n}\n\nlet fourArray = MatrixFlow.convertMultiArrayToArray4d(multiArray)\n```\n\n**Expected Result of type :** \n\n```swift\n[[[[0, 1], [1, 2], [2, 3], [3, 4]], [[1, 2], [2, 3], [3, 4], [4, 5]], [[2, 3], [3, 4], [4, 5], [5, 6]]]]\n//of type [[[[Decimal]]]]\n```\n\n---\n\n**2. MultiplyMatrices:** \n\nThe function accepts two 2D matrices and performs matrix multiplication. For instance, a (2, 4) matrix multiplied with a (4, 8) matrix.\n\n**Usage:**\n\n```swift\nimport MatrixFlow\nlet matrixA: [[Decimal]] = [[1, 2, 3], [4, 5, 6]]\nlet matrixB: [[Decimal]] = [[7, 8], [9, 10], [11, 12]]\n\n//Perform multiplication\nlet result = MatrixFlow.multiplyMatrices(matrixAA, matrixBB)\n\n//expected results of type [[Decimal]]: [[58, 64], [139, 154]]\n```\n\n---\n\n**3. ReshapeToMatrix:** \n\nThis function accepts a 2D matrix and reshapes it, effectively halving its dimensions. For example, it can transform a (3, 25600) matrix into a (3, 160, 160) structure.\n\n``` swift\nimport MatrixFlow\nlet flattenedArray: [Decimal] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]\nlet rows = 5\nlet columns = 5\n// specifiy the number of rows and columns you'll need accordingly\nlet result = MatrixFlow.reshapeToMatrix(array: flattenedArray, rows: rows, cols: columns)\n\n//expected result of type [[Decimal]]\n// [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]]\n\n```\n\n---\n\n**4. SigmoidMatrix:** \n\nImplements the sigmoid activation function to each cell of a matrix of type `[[Decimal]]`.\n\n**Usage:**\n\n```swift\nimport MatrixFlow\nlet matrix: [[Decimal]] = [\n    [1.8, 2.0, 3.0], \n    [4.9, 5.0, 6.0], \n    [7.0, 8.0, 9.0]\n]\n\nlet result: [[Decimal]] = MatrixFlow.sigmoidMatrix(matrix)\n//expected result: [[Decimal]] = [[0.8581489350995122176, 0.880797077977882624, 0.9525741268224335872], [0.9926084586557181952, 0.9933071490757152768, 0.9975273768433655808], [0.9990889488055998464, 0.9996646498695335936, 0.9998766054240137216]]\n```\n\n**5. ConvertMultiArrayToArray:**\n\nThis function is designed to convert an `MLMultiArray` with three dimensions into a 3D matrix ready for use.\n\n**Usage:**\n\n```swift\nimport MatrixFlow\nlet shape: [NSNumber] = [1, 3, 4]\n\nguard let multiArray = try? MLMultiArray(shape: shape, dataType: .float32) else {\n    fatalError(\"Failed to create MLMultiArray\")\n}\n\n// Populate the MLMultiArray\nfor i in 0..<shape[0].intValue {\n    for j in 0..<shape[1].intValue {\n        for k in 0..<shape[2].intValue {\n            let indices = [i, j, k] as [NSNumber]\n            multiArray[indices] = NSNumber(value: i + j + k)\n        }\n    }\n}\nlet result: [[[Decimal]]] = MatrixFlow.convertMultiArrayToArray(multiArray)\n\n// expected result: [[[Decimal]]] = [[[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5]]]\n```\n\n---\n\n**6. Transpose:**\n\n\nThis function transposes a 2D matrix, essentially swapping its rows with columns.\n\n**Usage:**\n``` swift\nimport MatrixFlow\nlet array: [[Decimal]] = [[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5]]\n\nlet result = MatrixFlow.transpose(array)\n\n//expected result: [[Decimal]] = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5]]\n```\n\n---\n\n**7. ReshapeArray:**\n\nThis function reshapes a 3D matrix by merging its last two dimensions.\n\n**Usage:**\n\n```swift\nimport MatrixFlow\nlet array: [[[Decimal]]] = [[[1.1, 1.2], [1.3, 1.4], [1.5, 1.6], [1.7, 1.8]], [[2.1, 2.2], [2.3, 2.4], [2.5, 2.6], [2.7, 2.8]], [[3.1, 3.2], [3.3, 3.4], [3.5, 3.6], [3.7, 3.8]]]\n\nlet result = MatrixFlow.reshapeArray(inputArray: array)\n\n//expected result: [[Decimal]] = [[1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8], [2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8], [3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8]]\n```\n\n---\n\n**8. Slice:**\n\nThis function performs matrix slicing. Given a matrix, it retrieves the first five rows.\n\n**Usage:**\n\n```swift\nimport MatrixFlow\nlet input: [[Decimal]] = [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 50], [11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 15], [21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 16]]\n\n//Specify the start and end index of the slicing\nlet start = 0\nlet end = 5\n\nlet result = MatrixFlow.slice(inputArray: input, start: 0, end: 5)\n\n//expected result: [[Decimal]] = [[1, 2, 3, 4, 5], [11, 12, 13, 14, 15], [21, 22, 23, 24, 25]]\n```\n\n---\n\n**9. CombineMatrix:**\n\nThis function is analogous to the numpy `hstack` operation. It horizontally stacks two matrices.\n\n**Usage:**\n\n```swift\nimport MatrixFlow\n// boxes and masks are named for illustration purposes\nlet arrayA: [[Decimal]] = [[1, 2, 3, 4, 5], [11, 12, 13, 14, 15], [21, 22, 23, 24, 25]]\nlet arrayB: [[Decimal]] = [[6, 7, 8, 9, 10, 50], [16, 17, 18, 19, 20, 15], [26, 27, 28, 29, 30, 16]]\n\nlet result = MatrixFlow.combineMatrix(boxes: arrayA, masks: arrayB)\n\n//expected results: [[Decimal]] = [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 50], [11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 15], [21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 16]]\n```",
  "homepage": "https://github.com/jadechoghari/MatrixFlow.git",
  "license": {
    "type": "MIT",
    "file": "LICENSE"
  },
  "authors": {
    "Jade Choghari": "chogharijade@gmail.com"
  },
  "social_media_url": "https://twitter.com/jadechoghari",
  "platforms": {
    "ios": "11.0"
  },
  "readme": "https://raw.githubusercontent.com/jadechoghari/MatrixFlow/main/README.md",
  "source": {
    "git": "https://github.com/jadechoghari/MatrixFlow.git",
    "tag": "0.0.3"
  },
  "source_files": "MatrixFlow/**/*.{swift,h,m}",
  "swift_version": "5.0"
}
